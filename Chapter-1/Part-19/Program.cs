#region Russian

/*

1.4.3. LINQ to SQL

Чтобы сообщить LINQ to SQL сведения о том, какие данные ожидать в таблицах,
понадобится проделать определенную работу, но она довольно прямолинейна и по большей 
части может быть автоматизирована. Мы перейдем прямо к коду запроса, который
показан в листинге 1.18. Определение класса LingDemoDataContext можно найти в
загружаемом исходном коде.

*/

// Листинг 1.18 Применение выражения запроса к базе данных SQL (C# 3)

using System;
using System.ComponentModel;
using System.Linq;

namespace Chapter01.CSharp3.Sql
{
    [Description("Listing 1.18")]
    class LinqToSql
    {
        static void Main()
        {
            using (LinqDemoDataContext db = new LinqDemoDataContext())
            {
                var filtered = from p in db.Products
                               join s in db.Suppliers
                               on p.SupplierID equals s.SupplierID
                               where p.Price > 10
                               orderby s.Name, p.Name
                               select new
                               {
                                   SupplierName = s.Name,
                                   ProductName = p.Name
                               };
                foreach (var v in filtered)
                {
                    Console.WriteLine("Supplier={0}; Product={1}", v.SupplierName, v.ProductName);
                }
            }
        }
    }
}

/*

Теперь код должен выглядеть очень знакомо. Все, что находится ниже строки с конструкцией join, 
было без изменений скопировано из листинга 1.16.

Несмотря на впечатляющий вид, возникает вопрос, касающийся производительности: зачем извлекать 
все данные из базы и затем применять к ним указанные запросы и упорядочение .NET? 
Почему бы ни поручить эту работу базе данных? Ведь это то, что
база данных умеет хорошо делать, не так ли? Безусловно, это так - но точно такую же
работу выполняет и LINQ to SQL. Код в листинге 1.18 выдает запрос к базе данных,
который по существу является запросом, транслируемым в SQL. Хотя запрос выражен
в коде С#, он выполняется как запрос SQL.

Позже вы увидите, что для реализации такого соединения существует подход, в
большей степени ориентированный на отношения, когда схеме и сущностям известно
отношение между поставщиками и товарами. Тем не менее, результат будет тем же самым, 
что просто демонстрирует сходные черты LINQ to Objects (язык LINQ, работающий 
с коллекциями в памяти) и LINQ to SQL.

Язык LINQ обладает исключительной гибкостью - можно построить собственный
поставщик для взаимодействия с веб-службой или транслировать запрос в какое-то
специализированное представление. В главе 13 будет показано, насколько в 
действительности широко понятие LINQ и как оно может выйти за рамки запрашивания 
коллекции.

*/

#endregion

